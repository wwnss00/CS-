# 자료구조 정리

## 1. 알고리즘
알고리즘은 특정 목적을 이루기 위한 연산 절차의 집합입니다.

- **시간 복잡도**: 입력 크기에 따른 프로그램 실행 시간의 관계
- **공간 복잡도**: 프로그램이 실행될 때 필요한 메모리 자원의 양

> **빅오 표기법**: 함수의 점근적 상한을 표기하는 방법으로, 알고리즘의 성능을 평가할 때 사용됩니다.

## 2. 배열 (Array)
- 일정한 메모리 공간을 차지하는 여러 요소들이 **순차적으로 나열된 자료구조**입니다.
- **인덱스(Index)**: 각 요소에 0부터 시작하는 고유한 순서번호를 부여합니다.

## 3. 연결 리스트 (Linked List)
- **노드(Node)**들의 모음으로 구성된 자료구조입니다.
- **노드(Node)**는 데이터와 다음 노드의 주소를 포함합니다.
- 메모리상 연속적으로 저장될 필요 없이 **불연속적인 데이터 저장에 유용**합니다.

### 연결 리스트의 종류
1. **싱글 연결 리스트 (Singly Linked List)**: 다음 노드의 위치 정보만 포함 → **단방향**
2. **이중 연결 리스트 (Doubly Linked List)**: 다음 노드와 이전 노드의 위치 정보 포함 → **양방향**
3. **환형 연결 리스트 (Circular Linked List)**: 마지막 노드가 첫 번째 노드를 가리켜 원형 구조를 이룸

## 4. 스택 (Stack)
- 한쪽에서만 데이터의 **삽입(푸시, Push) 및 삭제(팝, Pop)**이 가능한 자료구조
- **후입선출(LIFO, Last In First Out)** 방식
- **사용 사례**:
  1. 임시 저장된 데이터를 가장 먼저 활용해야 할 때
  2. 뒤로 가기 기능을 만들 때

## 5. 큐 (Queue)
- 한쪽에서 데이터를 삽입하고, 다른 한쪽에서 데이터를 삭제할 수 있는 자료구조
- **선입선출(FIFO, First In First Out)** 방식

### 큐의 변형
1. **원형 큐 (Circular Queue)**: 큐의 양 끝을 연결해 원형으로 사용
2. **덱 (Deque, Double-ended Queue)**: 양쪽에서 삽입/삭제 가능
3. **우선순위 큐 (Priority Queue)**: 데이터가 삽입 순서가 아닌 우선순위 기준으로 처리됨

## 6. 해시 테이블 (Hash Table)
- **키(Key)와 값(Value)**의 대응으로 이루어진 자료구조
- **해시 함수(Hash Function)**를 이용해 키를 특정 **버킷(Bucket) 배열의 인덱스**로 변환

### 해시 충돌 해결 방법
1. **체이닝(Chaining)**: 충돌 발생 시 연결 리스트를 활용하여 추가 저장
2. **개방 주소법 (Open Addressing)**: 다른 비어있는 버킷을 찾아 저장
   - **선형 조사법 (Linear Probing)**: 충돌 발생 시 다음 인덱스를 순차적으로 확인
   - **이중 해싱 (Double Hashing)**: 다른 해시 함수를 사용해 새로운 인덱스를 찾음

## 7. 트리 (Tree)
- 계층적 구조를 표현하는 자료구조
- **노드(Node)**와 **간선(Edge)**로 구성되며, 노드는 부모-자식 관계를 가짐

### 트리의 주요 개념
- **루트 노드(Root Node)**: 최상단 노드
- **리프 노드(Leaf Node)**: 자식 노드가 없는 최하단 노드
- **서브트리(Subtree)**: 트리 안에 포함된 작은 트리
- **차수(Degree)**: 노드가 가지는 자식 노드의 수
- **레벨(Level)**: 루트 노드에서 특정 노드까지의 거리 (간선 수)

---
# 자료구조 정리

## 트리 (Tree)

### 트리의 개념 및 구현
- 트리는 계층적인 구조를 표현하는 자료구조.
- 노드는 ‘데이터 저장 공간’과 ‘자식 노드의 위치 정보(메모리 주소)’로 구성.

### 트리의 순회 방법
- **전위 순회 (Preorder Traversal)**: 루트 → 왼쪽 서브트리 → 오른쪽 서브트리
- **중위 순회 (Inorder Traversal)**: 왼쪽 서브트리 → 루트 → 오른쪽 서브트리
- **후위 순회 (Postorder Traversal)**: 왼쪽 서브트리 → 오른쪽 서브트리 → 루트

### 이진 트리 (Binary Tree)
- **이진 트리**: 모든 노드의 자식 노드 개수가 2개 이하인 트리
- **편향된 이진 트리**: 한쪽으로만 치우친 이진 트리
- **정 이진 트리 (Full Binary Tree)**: 각 노드가 0개 또는 2개의 자식 노드를 가짐
- **포화 이진 트리 (Perfect Binary Tree)**: 모든 리프 노드가 같은 레벨에 존재
- **완전 이진 트리 (Complete Binary Tree)**: 왼쪽부터 차례로 채워진 트리

### 이진 탐색 트리 (Binary Search Tree, BST)
- 왼쪽 서브트리는 루트보다 작은 값, 오른쪽 서브트리는 루트보다 큰 값으로 구성.

### 힙 (Heap)
- 완전 이진 트리의 한 종류로, 최대값 또는 최소값을 빠르게 찾는 데 사용됨.
- **최대 힙 (Max Heap)**: 부모 노드 ≥ 자식 노드
- **최소 힙 (Min Heap)**: 부모 노드 ≤ 자식 노드

### 자가 균형 이진 탐색 트리 (Self-Balancing BST)
- 왼쪽과 오른쪽 서브트리의 높이 차이를 최소화하여 균형 유지.
- 대표적인 트리: **AVL 트리**, **레드-블랙 트리 (RB 트리)**

#### 레드-블랙 트리 (Red-Black Tree)
- 균형을 유지하기 위해 노드에 색(빨강/검정)을 할당.
- 규칙:
  1. 루트 노드는 블랙
  2. 리프 노드는 블랙 (NIL 노드)
  3. 레드 노드의 자식 노드는 블랙
  4. 루트에서 임의의 리프까지의 경로에서 블랙 노드 개수는 동일해야 함

### B-트리 (B-Tree)
- RB 트리처럼 균형을 유지하지만, 한 노드가 여러 자식 노드를 가질 수 있는 다진 탐색 트리 (M-ary Tree).
- 대용량 데이터 입출력에 적합.

---

## 그래프 (Graph)

### 그래프의 개념 및 특징
- 정점(Vertices)과 간선(Edges)으로 이루어진 자료구조.
- 트리는 그래프의 한 종류지만, 그래프는 트리보다 더 일반적인 개념.

### 그래프의 종류
1. **연결 그래프 (Connected Graph)**: 모든 정점이 연결됨
2. **비연결 그래프 (Disconnected Graph)**: 일부 정점이 연결되지 않음
3. **방향 그래프 (Directed Graph, Digraph)**: 간선에 방향이 있음
4. **무방향 그래프 (Undirected Graph)**: 간선에 방향이 없음
5. **가중치 그래프 (Weighted Graph)**: 간선에 가중치(비용)가 부여됨
6. **서브그래프 (Subgraph)**: 특정 그래프의 일부 정점과 간선으로 구성된 그래프

### 그래프의 표현 방법
- **인접 행렬 (Adjacency Matrix)**: 정점 간 연결 여부를 2차원 배열로 저장
- **인접 리스트 (Adjacency List)**: 각 정점이 연결된 정점 목록을 저장

---

## 정리
트리와 그래프는 자료구조에서 핵심적인 개념이며, 탐색 및 정렬, 데이터 저장 등의 다양한 분야에서 활용된다. 특히, 이진 탐색 트리와 힙은 효율적인 데이터 검색과 정렬에, 그래프는 네트워크 구조 및 경로 탐색에 자주 사용된다.



